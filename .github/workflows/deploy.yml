name: Deploy WSO2 MI to Minikube

on:
  workflow_dispatch:  # Manual trigger via GitHub UI or API

permissions:
  contents: read
  packages: write

env:
  DOCKER_IMAGE_TAG: helloworldservice:1.0.0
  WSO2_SERVER_HOME: /home/wso2carbon/wso2mi-4.4.0
  MINIKUBE_VERSION: v1.36.0

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04

    steps:
      # 1. Debug Runner Environment
      - name: Debug Runner Environment
        run: |
          echo "Runner OS:"
          uname -a
          echo "Disk space:"
          df -h
          echo "Environment variables:"
          env
          echo "Current directory:"
          pwd

      # 2. Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4
      - name: Debug Repository Contents
        run: |
          echo "Listing repository contents:"
          ls -laR ${{ github.workspace }}
          echo "Checking for pom.xml:"
          if [ ! -f "${{ github.workspace }}/pom.xml" ]; then
            echo "Error: pom.xml not found"
            exit 1
          fi
          echo "Checking for API definition:"
          if [ ! -f "${{ github.workspace }}/src/main/resources/HelloWorld_1.0.0/HelloWorld-1.0.0.xml" ]; then
            echo "Error: API definition not found"
            exit 1
          fi
          echo "Checking for Dockerfile:"
          if [ ! -f "${{ github.workspace }}/deployment/docker/Dockerfile" ]; then
            echo "Error: Dockerfile not found"
            exit 1
          fi

      # 3. Set up JDK 11
      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
      - name: Debug Java and Maven
        run: |
          echo "Java version:"
          java -version
          echo "Maven version:"
          mvn --version

      # 4. Build CAR File
      - name: Build CAR File
        run: |
          echo "Building CAR file..."
          mvn clean package -X || { echo "Maven build failed"; exit 1; }
          echo "Listing target directory:"
          ls -la ${{ github.workspace }}/target/
          CAR_FILE=$(find ${{ github.workspace }}/target -type f -name "*.car" | head -n 1)
          if [ -z "$CAR_FILE" ]; then
            echo "Error: No CAR file found"
            exit 1
          fi
          echo "CAR file found: $CAR_FILE"
          echo "Checking CAR file contents:"
          unzip -l "$CAR_FILE"

      # 5. Copy CAR File
      - name: Copy CAR File
        run: |
          echo "Copying CAR file to deployment/docker/CompositeApps/"
          mkdir -p ${{ github.workspace }}/deployment/docker/CompositeApps
          cp ${{ github.workspace }}/target/*.car ${{ github.workspace }}/deployment/docker/CompositeApps/
          ls -la ${{ github.workspace }}/deployment/docker/CompositeApps/

      # 6. Build Docker Image
      - name: Build Docker Image
        run: |
          echo "Building Docker image..."
          docker build -t ${{ env.DOCKER_IMAGE_TAG }} -f ${{ github.workspace }}/deployment/docker/Dockerfile ${{ github.workspace }} || { echo "Docker build failed"; exit 1; }
          echo "Listing built images:"
          docker images | grep helloworldservice

      # 7. Set up Minikube (Fallback Manual Installation)
      - name: Install Minikube Manually
        run: |
          echo "Downloading Minikube ${{ env.MINIKUBE_VERSION }}..."
          curl -LO https://github.com/kubernetes/minikube/releases/download/${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64
          echo "Verifying checksum..."
          curl -LO https://github.com/kubernetes/minikube/releases/download/${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64.sha256
          echo "$(cat minikube-linux-amd64.sha256) minikube-linux-amd64" | sha256sum -c || { echo "Checksum verification failed"; exit 1; }
          echo "Installing Minikube..."
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          echo "Minikube installed successfully."
          minikube version

      - name: Start Minikube
        run: |
          echo "Starting Minikube with Kubernetes v1.33.1..."
          minikube start --driver=docker --memory=4096 --cpus=2 --ports=8290,9164 --kubernetes-version=v1.33.1 || { echo "Minikube start failed"; exit 1; }
          echo "Minikube status:"
          minikube status
          echo "kubectl version:"
          kubectl version --client
          echo "kubectl cluster info:"
          kubectl cluster-info

      # 8. Load Docker Image into Minikube
      - name: Load Docker Image to Minikube
        run: |
          echo "Loading Docker image into Minikube..."
          minikube image load ${{ env.DOCKER_IMAGE_TAG }} || { echo "Image load failed"; exit 1; }
          echo "Listing Minikube images:"
          minikube image ls | grep helloworldservice

      # 9. Deploy to Minikube
      - name: Deploy to Minikube
        run: |
          echo "Applying Kubernetes manifests..."
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: wso2mi-deployment
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: wso2mi
            template:
              metadata:
                labels:
                  app: wso2mi
              spec:
                containers:
                - name: wso2mi
                  image: ${{ env.DOCKER_IMAGE_TAG }}
                  imagePullPolicy: Never
                  ports:
                  - containerPort: 8290
                  - containerPort: 9164
                  env:
                  - name: WSO2_SERVER_HOME
                    value: "${{ env.WSO2_SERVER_HOME }}"
                  readinessProbe:
                    httpGet:
                      path: /management/health
                      port: 9164
                      scheme: HTTPS
                    initialDelaySeconds: 40
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: wso2mi-service
          spec:
            selector:
              app: wso2mi
            ports:
            - name: http
              port: 8290
              targetPort: 8290
            - name: https
              port: 9164
              targetPort: 9164
            type: ClusterIP
          EOF
          echo "Listing pods:"
          kubectl get pods -o wide || echo "Failed to list pods"

      # 10. Test Deployment and API
      - name: Test Deployment and API
        run: |
          echo "Waiting for deployment to be ready..."
          kubectl wait --for=condition=available deployment/wso2mi-deployment --timeout=300s || { echo "Deployment not ready"; exit 1; }
          echo "Checking pod logs for CAR deployment..."
          kubectl logs -l app=wso2mi > k8s_logs.txt
          cat k8s_logs.txt
          echo "Checking for errors in logs..."
          grep -i "error" k8s_logs.txt || echo "No errors found in logs"
          echo "Checking CAR deployment..."
          grep "Deploying Carbon Application" k8s_logs.txt || echo "No deployment message found"
          echo "Port-forwarding to test API..."
          kubectl port-forward svc/wso2mi-service 9164:9164 &
          sleep 5
          API_RESPONSE=$(curl -k -s -w "%{http_code}" https://localhost:9164/helloworld)
          if [[ "$API_RESPONSE" =~ "200" ]]; then
            echo "API is responding successfully!"
          else
            echo "Error: API test failed with response: $API_RESPONSE"
            cat k8s_logs.txt
            exit 1
          fi

      # 11. Upload Artifacts
      - name: Upload Logs and CAR
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: k8s-artifacts
          path: |
            k8s_logs.txt
            target/*.car
          retention-days: 7