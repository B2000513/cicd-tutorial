name: Deploy WSO2 MI to Minikube with Tunneling

on:
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  DOCKER_IMAGE_TAG: helloworldservice:1.0.0
  WSO2_SERVER_HOME: /home/wso2carbon/wso2mi-4.4.0
  DOCKERHUB_REPOSITORY: ianwong123/helloworldservice  # Replace with your Docker Hub username
  MINIKUBE_VERSION: v1.36.0
  KUBERNETES_VERSION: v1.33.1
  WAIT_DURATION: 3600  # Wait for 1 hour (3600 seconds) for testing; adjust as needed (max 21600 for 6 hours)

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # 1. Debug Runner Environment
      - name: Debug Runner Environment
        run: |
          echo "Runner OS:"
          uname -a
          echo "Disk space:"
          df -h
          echo "Environment variables:"
          env
          echo "Current directory:"
          pwd

      # 2. Install Minikube and kubectl
      - name: Install Minikube and kubectl
        run: |
          echo "Installing Minikube ${{ env.MINIKUBE_VERSION }}..."
          curl -LO --fail https://github.com/kubernetes/minikube/releases/download/${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64 || { echo "Failed to download Minikube"; exit 1; }
          curl -LO --fail https://github.com/kubernetes/minikube/releases/download/${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64.sha256 || { echo "Failed to download checksum"; exit 1; }
          echo "$(cat minikube-linux-amd64.sha256) minikube-linux-amd64" | sha256sum -c || { echo "Checksum verification failed"; exit 1; }
          chmod +x minikube-linux-amd64
          sudo mv minikube-linux-amd64 /usr/local/bin/minikube
          echo "Minikube installed successfully."
          minikube version
          echo "Installing kubectl ${{ env.KUBERNETES_VERSION }}..."
          curl -LO --fail https://dl.k8s.io/release/${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl || { echo "Failed to download kubectl"; exit 1; }
          curl -LO --fail https://dl.k8s.io/${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl.sha256 || { echo "Failed to download kubectl checksum"; exit 1; }
          echo "$(cat kubectl.sha256) kubectl" | sha256sum -c || { echo "Checksum verification failed"; exit 1; }
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          echo "kubectl installed successfully."
          kubectl version --client

      # 3. Start Minikube
      - name: Start Minikube
        run: |
          echo "Starting Minikube with Kubernetes ${{ env.KUBERNETES_VERSION }}..."
          sudo sysctl fs.protected_regular=0
          minikube start --driver=docker --kubernetes-version=${{ env.KUBERNETES_VERSION }} --memory=4096 --cpus=2 --ports=8290,9164 || { echo "Minikube start failed"; exit 1; }
          echo "Minikube status:"
          minikube status
          echo "kubectl cluster info:"
          kubectl cluster-info

      # 4. Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v4

      # 5. Set up JDK 11
      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'

      # 6. Build CAR File
      - name: Build CAR File
        run: |
          echo "Building CAR file..."
          mvn clean package -X || { echo "Maven build failed"; exit 1; }
          echo "Listing target directory:"
          ls -la ${{ github.workspace }}/target/
          CAR_FILE=$(find ${{ github.workspace }}/target -type f -name "*.car" | head -n 1)
          if [ -z "$CAR_FILE" ]; then
            echo "Error: No CAR file found"
            exit 1
          fi
          echo "CAR file found: $CAR_FILE"
          echo "Checking CAR file contents:"
          unzip -l "$CAR_FILE"

      # 7. Copy CAR File
      - name: Copy CAR File
        run: |
          echo "Copying CAR file to deployment/docker/CompositeApps/"
          mkdir -p ${{ github.workspace }}/deployment/docker/CompositeApps
          cp ${{ github.workspace }}/target/*.car ${{ github.workspace }}/deployment/docker/CompositeApps/
          ls -la ${{ github.workspace }}/deployment/docker/CompositeApps/

      # 8. Build Docker Image
      - name: Build Docker Image
        run: |
          echo "Building Docker image..."
          docker build -t ${{ env.DOCKERHUB_REPOSITORY }}:${{ env.DOCKER_IMAGE_TAG }} -f ${{ github.workspace }}/deployment/docker/Dockerfile ${{ github.workspace }} || { echo "Docker build failed"; exit 1; }
          echo "Listing built images:"
          docker images | grep helloworldservice

      # 9. Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 10. Push Docker Image to Docker Hub
      - name: Push Docker Image to Docker Hub
        run: |
          echo "Pushing Docker image to Docker Hub..."
          docker push ${{ env.DOCKERHUB_REPOSITORY }}:${{ env.DOCKER_IMAGE_TAG }} || { echo "Docker push failed"; exit 1; }

      # 11. Load Docker Image to Minikube
      - name: Load Docker Image to Minikube
        run: |
          echo "Configuring Docker to use Minikube's Docker daemon..."
          eval $(minikube docker-env)
          echo "Loading Docker image into Minikube..."
          minikube image load ${{ env.DOCKERHUB_REPOSITORY }}:${{ env.DOCKER_IMAGE_TAG }} || { echo "Image load failed"; exit 1; }
          echo "Listing Minikube images:"
          minikube image ls | grep helloworldservice

      # 12. Deploy to Minikube with Multiple Ports
      - name: Deploy to Minikube
        run: |
          echo "Applying Kubernetes manifests..."
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: wso2mi-deployment
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: wso2mi
            template:
              metadata:
                labels:
                  app: wso2mi
              spec:
                containers:
                - name: wso2mi
                  image: ${{ env.DOCKERHUB_REPOSITORY }}:${{ env.DOCKER_IMAGE_TAG }}
                  imagePullPolicy: Always
                  ports:
                  - containerPort: 8290
                  - containerPort: 9164
                  # Add more ports here if needed, e.g.:
                  # - containerPort: 8080
                  env:
                  - name: WSO2_SERVER_HOME
                    value: "${{ env.WSO2_SERVER_HOME }}"
                  readinessProbe:
                    httpGet:
                      path: /management/health
                      port: 9164
                      scheme: HTTPS
                    initialDelaySeconds: 40
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: wso2mi-service
          spec:
            selector:
              app: wso2mi
            ports:
            - name: http
              port: 8290
              targetPort: 8290
              nodePort: 30080
            - name: https
              port: 9164
              targetPort: 9164
              nodePort: 30081
            # Add more ports here if needed, e.g.:
            # - name: custom-port
            #   port: 8080
            #   targetPort: 8080
            #   nodePort: 30082
            type: NodePort
          EOF
          echo "Listing pods:"
          kubectl get pods -o wide
          echo "Listing services:"
          kubectl get svc

      # 13. Install ngrok
      - name: Install ngrok
        run: |
          echo "Installing ngrok..."
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt update
          sudo apt install ngrok
          ngrok version

      # 14. Expose Minikube Service via ngrok
      - name: Expose Minikube Service via ngrok
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        run: |
          echo "Configuring ngrok..."
          ngrok config add-authtoken $NGROK_AUTH_TOKEN
          echo "Starting ngrok for port 30080 (HTTP)..."
          ngrok http 30080 --log=stdout > ngrok_http.log &
          echo "Starting ngrok for port 30081 (HTTPS)..."
          ngrok http 30081 --log=stdout > ngrok_https.log &
          # Add more ngrok tunnels for additional ports, e.g.:
          # ngrok http 30082 --log=stdout > ngrok_custom.log &
          sleep 10
          echo "Retrieving ngrok public URLs..."
          NGROK_HTTP_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.config.addr | contains("30080")) | .public_url')
          NGROK_HTTPS_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.config.addr | contains("30081")) | .public_url')
          # Add more URL retrieval for additional ports, e.g.:
          # NGROK_CUSTOM_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.config.addr | contains("30082")) | .public_url')
          echo "Public URL for HTTP (8290): $NGROK_HTTP_URL"
          echo "Public URL for HTTPS (9164): $NGROK_HTTPS_URL"
          # echo "Public URL for Custom (8080): $NGROK_CUSTOM_URL"
          echo "NGROK_HTTP_URL=$NGROK_HTTP_URL" >> $GITHUB_ENV
          echo "NGROK_HTTPS_URL=$NGROK_HTTPS_URL" >> $GITHUB_ENV
          # echo "NGROK_CUSTOM_URL=$NGROK_CUSTOM_URL" >> $GITHUB_ENV

      # 15. Test API Availability
      - name: Test API Availability
        run: |
          echo "Testing HTTP API at ${{ env.NGROK_HTTP_URL }}..."
          curl -k -v ${{ env.NGROK_HTTP_URL }} || echo "HTTP check failed, check logs"
          echo "Testing HTTPS API at ${{ env.NGROK_HTTPS_URL }}/management/health..."
          curl -k -v ${{ env.NGROK_HTTPS_URL }}/management/health || echo "HTTPS health check failed, check logs"
          # Add tests for additional ports, e.g.:
          # curl -k -v ${{ env.NGROK_CUSTOM_URL }}/<endpoint> || echo "Custom port check failed, check logs"

      # 16. Wait for Postman Testing
      - name: Wait for Postman Testing
        run: |
          echo "Workflow will wait for ${{ env.WAIT_DURATION }} seconds to allow Postman testing."
          echo "Use the following URLs in Postman:"
          echo "HTTP (8290): ${{ env.NGROK_HTTP_URL }}"
          echo "HTTPS (9164): ${{ env.NGROK_HTTPS_URL }}"
          # echo "Custom (8080): ${{ env.NGROK_CUSTOM_URL }}"
          sleep ${{ env.WAIT_DURATION }}
          echo "Stopping workflow after wait period."